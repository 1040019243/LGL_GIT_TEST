15770f2kga6rj


面试题目：

一、编程是函数概念还是闭包概念
闭包的概念	即函数中定义的函数，由于它可以访问外围定义的变量，好像把外围“包起来”，称为闭包。
	我的理解是，闭包就是能够读取其他函数内部变量的函数。因此可以把闭包简单理解成"定义在一个函数内部的函数。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
	这种对外部作用域的变量进行引用的内部函数就称为闭包。
闭包的用途
	它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
	可以通过改变某些外部变量的值来改变闭包的运行效果。
	所以常规操作就是使用一些类似闭包的灵活功能，通过修改配置的方式改变代码的逻辑。
	除此之外闭包还有一个用处是可以暂存变量或者是运行时的环境。
使用闭包的注意点
	1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
	解决方法是，在退出函数之前，将不使用的局部变量全部删除。
	2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），
	把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
	不能直接访问外部的变量
	不能使用循环变量

函数编程
	意思是，把函数和其他类型等同对待，可以定义函数局部变量，可以将函数作为参数，也可以返回函数。
	函数式编程是种编程方式，它将电脑运算视为函数的计算。和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。
	和过程化编程相比，函数式编程里函数的计算可随时调用。
	函数式编程的本质是：把函数看作是数据。这种把程序（以函数为单位）当作数据使用的程序处理法，就叫函数式编程。这是它的内涵。
	函数式编程(Functional programming)是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和复杂的状态维护。
	相比命令式编程(imperative programming)，函数式编程更强调函数的应用，而命令式编程更强调状态的变化和命令的执行顺序[1]

	在函数式编程中使用高阶函数的概念。当一个函数可以接受函数作为参数，或将函数作为返回结果时，该函数称之为高阶函数[3]。
	与高阶函数紧密相关的另一个概念，是一等公民函数(first-class function)。它和高阶函数的区别在于：高阶函数是一个数学概念，表示该函数可以操作其他函数；
	一等公民是一个计算机科学术语，表示该编程语言对函数的使用无限制(类似其他一等公民，例如数字类型，可以出现在任何地方，例如作为函数参数或函数返回值)。
	通过高阶函数，可以实现柯里化(currying)功能，使用函数柯里化，可以每接收一个参数就返回一个新函数。

	如果一个函数是纯函数，则代表该函数无任何副作用。因为纯函数不会更改传入数据，因此纯函数是现成安全的。
	而如果函数有副作用，多次调用会产生不一样的值，则无法进行公共子表达式消除。例如如下代码：

	函数式编程中循环和迭代功能一般使用递归实现。




二、Python的迭代器和生成器
迭代器：
	迭代器和迭代过程：迭代就是从迭代器中取元素的过程。比如我们用for循环从列表[1,2,3]中取元素，这种遍历过程就被称作迭代。
	在Python中，迭代器是遵循迭代协议的对象。使用iter()从任何序列对象中得到迭代器（如list, tuple, dictionary, set等）。另一种形式的输入迭代器是generator（生成器）。
	python中，任意对象，只要定义了__next__方法，它就是一个迭代器。

	运用：
	如果你不想用for循环迭代呢？这时你可以：
	先调用容器（以字符串为例）的iter()函数，再使用 next() 内置函数来调用 __next__() 方法，当元素用尽时，__next__() 将引发 StopIteration 异常

生成器：
	另一种形式的输入迭代器是generator（生成器）。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。
	生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。
	可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。但生成器的写法更为紧凑，因为它会自动建 __iter__() 和 __next__()方法。

	注意
	生成器表达式也是返回生成器generator对象，一次只返回一个值。

	一、迭代器

	1、迭代器iterator中只能包含可迭代对象。可用于for循环的对象是可迭代对象Iterable，如list，tuple等，可迭代对象不能用__next__()访问元素
	2、能用于for循环，且能通过__next__()访问的对象是迭代器Iterator，如生成器就是一个迭代器对象
	3、只能通过__next__()依次获取迭代器中的元素，不能通过下标才查找
	4、读取量很大的数据时，用迭代器可节省内存
	

	生成器：
	返回迭代器的函数是一个生成器generator。生成器可用于for循环，也可用__next__()取值

	迭代器
	迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。
	其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常
	__iter__()和next()方法
	这两个方法是迭代器最基本的方法，一个用来获得迭代器对象，一个用来获取容器中的下一个元素。
	对于可迭代对象，可以使用内建函数iter()来获取它的迭代器对象
	其实，当我们使用for语句的时候，for语句就会自动的通过__iter__()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。

	生成器
	在Python中，使用生成器可以很方便的支持迭代器协议。生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，
	但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。
	也就是说，yield是一个语法糖，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。
	当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有 执行。
	当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止
	next()方法的返回值就是yield语句处的参数（yielded value）
	当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常


	本文介绍了Python迭代器和生成器的相关内容。

通过实现迭代器协议对应的__iter__()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。
像列表这种序列类型的对象，可迭代对象和迭代器对象是相互独立存在的，在迭代的过程中各个迭代器相互独立；但是，有的可迭代对象本身又是迭代器对象，那么迭代器就没法独立使用。
itertools模块提供了一系列迭代器，能够帮助用户轻松地使用排列、组合、笛卡尔积或其他组合结构。
 

生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义__iter__()和next()方法。
生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。


git config --global user.email "glennli@126.com"
git config --global user.name "GlennLi"

SSH：
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDULpVJR3Nq48tQQbjhHk+plYASo4BDdi+td5b9GfDKDekfPUiv4jPDZioCQXAHaxM59I+dUYKjJzDz/oFM8QpZGi2RzHbEVhtKSugHCNAI/W+RCM1B5ZQiaINPeH/05gobbBmYk0zEnfi5HocIfk7oedOV3/AQtYY0x9DhBDHm2UE3f16LcYQcG79G7fImFdGSAQH28VXjzAqumyRl9CCJqvXjo0wrK0dQcjlo3mw8cSyN9yqzhL+EPk8fYhGHFYKSGUN9wU8P542BDRNW9lgFZDCXD1YZLyeY9wHNex9UcF9NtOrkJ7HNPZJwwoa8g4VJy6K5bbw96WqrkUJs83Cp lgl@SYZS

ssh-keygen -t rsa -C "glennli@126.com"